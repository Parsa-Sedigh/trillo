/*COLORS
Primary: #eb2f64
Primary light: #FF3366
Primary dark: #BA265D
Grey light 1: #faf9f9
Grey light 2: #f4f2f2
Grey light 3: #f0eeee
Grey light 4: #ccc
Grey dark 1: #333
Grey dark 2: #777
Grey dark 3: #999*/
/* 2) Why flexbox, an overview of the philosophy behind flexbox:
What is flexbox?
Flexbox is a new module in CSS3 that makes it easy to align elements to one another, in different directions and orders and also
to CHANGE those alignments if necessary.
When we wanna change those alignments?
For example in responsive design and that works perfectly, even if you have no idea about the dimensions of those elements that you
want to align them.
Because the main idea behind flexbox is to give the give the container the ability to expand and to shrink to best use all
of the available space.
So with flexbox, you can easily replace float layouts, with much less and much more readable and logical code.
And because of that, flexbox completely changes the way that we build layouts and especially one-dimensional layouts.
For 2-dimensional layouts, there are better ways of building them. Like using css grid layout.

The element which we use flexbox on it, is called the flex container and in order to create a flex container, is to set it's
display prop to flex. We can also set it to flex-inline which creates a flex container which behaves like an inline element.
But we always never use that one.
All the direct children of the flex container, are called the flex items.
The direction which these flex items are laid out is called the main axis and the other perpendicular axis is called the
cross axis.


------------------------> MAIN AXIS
        |
        |
        |
        |
        |
        |
        |
    CROSS AXIS

Notice: The x-y axis in css are exactly like the axises in flex-box. So in general css we have: ------>x
                                                                                                |
                                                                                                |
                                                                                                |
                                                                                                Y

We can change the direction of main axis and also there are different ways of aligning elements along both main axis and
the cross axis.

The flexbox specification, defines a couple of properties that we use on the flex container in order to position and
align all of the flex items and then we have also some other properties that we use directly on the flex items themselves.
The properties that we use on the flex container(the first value is the default or initial value of that prop):
1) flex-direction: row | row-reverse | column | column-reverse
This prop specifies in which direction, the main axis goes. You can see the flex-direction: row; in the example above.

2) flex-wrap: nowrap | wrap | wrap-reverse
This prop specifies if the flex items should wrap into a new line, if there's not enough space in the flex container, or not.

3) justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly
This prop defines how the flex items will be aligned along the main axis.

4) align-items: flex-start | flex-end | center | baseline
This prop is very similar to justify-content with a difference which is this one defines how the flex items will be aligned
along the cross axis, not the main axis. So align-items, many times is used together with justify-content.

5) align-content: stretch | flex-start | flex-end | center | space-between | space-around
This prop only applies, when there's more than one row of flex items. So if there is more than 1 row of flex items, in that
case, align-content controls how the rows are aligned along the cross axis, IF there is some empty space there.

The properties that we use on the flex items:
1) align-self: auto | stretch | flex-start | flex-end | center | baseline
This prop is very similar to align-items but this prop is for one individual flex item. So imagine we set align-items: center; ,
but then we want one of the flex items to be aligned to the bottom, therefore we can use align-self for that.

2) order: 0 | <integer>
This prop defines the order which in that order, one specific flex item should appear inside the flex container and this is
really helpful to reorder flex items, for example for smaller screens.

Also we have 3 props that together, basically help flexbox to decides on the width of a flex item.
With flex-grow we define how much an item can grow, with flex-shrink we define how much it can shrink and with flex-basis
we can define it's base width.
3) flex-grow: 0 | <integer>
In this prop we define how much an flex item can grow

4) flex-shrink: 1 | <integer>
With this prop, we define how much a flex item can shrink.

5) flex-basis: auto | <length>
With this prop, we can define the base width of a flex item.

6) There's a shorthand prop for 3, 4 and 5 props, which is simply called flex and this one is actually the one that we should
use it instead of those 3 individual props.
flex: 0 1 auto | <int> <int> <len> */

/* 3) A basic intro to flexbox, the flex container:
In emmet, when you say:
.container>.item*5
It will create a div with class of container and then 5 CHILDREN(by using >) in that container with class of .item .
We can do some global reset and also set the border-box to box-sizing, by using universal selector.
Now let's focus on flexbox properties that we can apply on the container.

The first thing we have to do in order to use flexbox, is to set display prop to flex on the container. What happens after that is
flex items(the children of that container) would be automatically sit side by side, without using any float or display: inline-block;
on them. All we did was set the container to flex, then automatically the child elements of that container, become flex items and
sit side by side.
Now let's set flex-direction on the container. The default or initial value of that prop is row. So if you say row, nothing changes,
right? Because that's the default. Because by setting display to flex on the container, automatically the flex-direction is set to row,
without we need to say that. Like it's(flex-direction: row;) there but we couldn't see it.
If you say, row-reverse, it inverts the direction of main-axis. So the main-axis in that case, goes from RIGHT to left.

If you say: flex-direction: column; the flex-items are stacked one on top of another. So basically, the main-axis starts from
top to left and therefore the cross axis, starts from left to right.
If you use column-reverse, the main-axis will start from BOTTOM to TOP but the cross-axis will AGAIN start from LEFT TO RIGHT.
So this prop is handy for responsive designs. So on smaller screens in some cases, we can set the flex-direction to column and the
flex-items would be on top of each other.

justify-content is used to control how the flex-items should be positioned along the MAIN-AXIS.
If you set justify-content: center; to ON THE FLEX CONTAINER(which has display: flex; definitely), the items are in center of the
container(horizontally centered).
Important: But remember, justify-content: center; doesn't do anything to the space that's between the flex-items. Because the space that
 we have there, is defined by the margin that we have on the items.
So all the justify-content: center; does, is to put all the items in the center of flex-container.

By setting justify-content: space-between; on the flex container, the space between flex-items is evenly distributed between those
flex-items and flexbox automatically does all that calculation for us and automatically positions the elements like that. Also
if you change the width of the screen, then the space that's between those items ALSO ADJUSTS itself to the space of screen.

If you use justify-content: space-around; , it puts the same amount of space on BOTH(because by using justify-content: space-between; ,
it won't put space on the outer flex-items, outer means the items that are the first and last-but by using space-around, it will also
put space on both sides(the side that is not in between flex-items) of first and last items) left side and right side of each of the
flex-items. So the space in left and right side of a flex-item is the same(in space-around), which causes the inner spaces become
double of outer spaces.
Learn: So what this means, is the total space between 2 flex-items(the inner spaces) is DOUBLE the space that's of outer-space
 of first and last flex-items. The outer space in a row main-axis is the left side of first flex-item and the right side of last
 flex-item and the outer space in column main-axis is the top of the first flex-item and bottom space of last flex-item.

what justify-content: space-evenly; does, is that the space is always the same between inner spaces and also the outer spaces. So
all of the spaces are the same. So while space-evenly ensures that the space is always the same BETWEEN elements and ALSO on the
SIDES of the elements, space-around ensures that the amount of space AROUND each element(AROUND means left and right side of a
flex-item) is the same. So these are subtle differences.

Important: So space-between won't put space on outer spaces, space-around makes the left and right side of a flex-item have the
 same space(which causes the inner spaces double the outer-spaces) and space-evenly makes ALL OF THE SPACES(INNER AND OUTER) THE SAME.
 So: space-between, space-around space-evenly and center(which doesn't effect the space between our space outer of each item).
We also have justify-content: flex-end; all of the items will go to right side(when the flex-direction is set to row-default) and
also we have justify-content: flex-start which is the default(all of the items will be in left side of container-when the flex-direction
is set to row). These flex-start and flex-end won't effect the spaces.

justify-content defines how the flex-items are aligned ALONG THE MAIN-AXIS. But align-items defines how the flex-items are aligned
along the cross axis. So remember by default we have: ---------> main-axis and in general css we ALSO have the same: -------> x
                                                      |                                                              |
                                                      |                                                              |
                                                      |                                                              |
                                                      |                                                              |
                                                      |                                                              Y
                                                      cross-axis
Now in order for align-items to work and we see it visually, we actually need at least one of them to be bigger than the others.
Because right now, they're already perfectly aligned along the cross axis, so it's already centered vertically(why vertically?
Because the cross axis currently is from top to bottom.).
So if we make one of those items bigger or smaller than the others, then we can experiment with different alignments across the
cross axis by using align-items. So let's give one them a different height. If you do this, you instantly see that ALL OF THEM
growed and not JUST the .i2-but we just define a height for one of them, what happened?
That's because the initial or default value for align-items is stretch and we know that the align-items: stretch; is set on the
items from the beginning but we can't see it(it's a default).
By using align-items: center; you see that currently we have one element taller than the other items and with align-items set to
center, we basically centered those smaller items, relative to the taller item in vertical direction so in this case in the cross
axis and that taller one was already centered along the cross axis therefore the smaller ones are also centered along the cross axis.

By setting align-items to flex-start, then all of the items would be aligned at the top(would stick to starting place of cross axis).
and for align-items: flex-end; all of the items would stick to the ending point of cross axis(or bottom of cross axis-if the
flex-direction is set to row).

Now what does align-items: stretch do?
Learn: It simply stretches all of the OTHER elements to match the height of the highest flex-item.

For using align-items: baseline; let's increase the font-size on one of the items. Now if you set the baseline, it will basically
align the TEXT in the flex-items along a line. So if you draw an imaginary line there, UNDER those texes of each flex-item,
you see that they're completely aligned along that line.
So basically align-items: baseline; , align the text of each flex-item to their common text (or along a line).

So flex-direction, justify-content and align-items are crucial on flex containers. Also there are flex-wrap and align-content.

Now what happens to justify-content and align-items, when we change the flex-direction? So when flex-direction is set to column,
the main axis is no longer going from left to right(when it's set to row), but from the top tp bottom.
Now why the items are horizontally centered?
It's because of align-items: center; . Because the cross axis is now the horizontal line and remember that align-items is the
prop that controls the positioning or in better words alignment of items, along the CROSS axis.
So it's really crucial to keep track of where the main and cross axis are currently situated, in order to use the justify-content and
align-items in the correct way.
When flex-direction is column, if you set justify-content to center, the items along the main axis which in that case is going
from top to bottom, are centered. */
/* 4. A basic intro to flexbox - flex items:
align-self, overrides the align-items prop for one individual item. So right now, the align-items is set to center, so all of the
items are centered along the cross axis, cross axis currently is from top to bottom. But if you want to override align-items for
one individual item, let's say for the fourth item, let's give it a class of .i4 and in that class, we set align-self to flex-end.
So now all of the items, except that one, are aligned to the center of cross axis.

When you say: align-items: stretch; for all of the items or align-self: stretch; for individual item, those or that items, will
stretch in order to fill the entire container along the cross axis. Also when one item is set to stretch and another one is set
to flex-end(for their align-self props), the one that is flex-end will go where that stretch ends there.

The initial value of order is 0 and if you want to put one of the items at the beginning, all we need to do is to put a value lower
than 0. But why is that?
Flexbox orders all of those items according to their order number and flexbox starts ordering items from the lowest order number the
item with lowest order, goes to the beginning. Also the highest order goes to the end. This order prop is handy for responsive design,

Learn: flex-grow is the ability of an item to grow and for it's value, we specify an integer. When you say: flex-grow: 1; , now all
 of the items occupy the entire space that they can. Or in other words, they grow as much as they can. So now they're occupying
 all the space that they possibly can.
If those items haven't any margins, at least the inner margins, so now they're actually TOUCHING one another, again because they
occupy all the space that they can and that's what flex-grow does. Now if we set all of the items an order prop even with a higher
number than 1, it doesn't really matter, because the value of order prop only matters in RELATION to other numbers of flex-grow in
other items.
Important: So if we set flex-grow for all of the items to 1 and then set the flex-grow for one item to 2, that item with flex-grow
 of 2 is now DOUBLE the SIZE of other items which have flex-grow of 1 and that's because 2 is double of 1. So that item has twice
 the ability to grow than the other items which have flex-grow of 1. But those items with flex-grow: 1; would still grow as much
 as they can but they are 2 times smaller than the item with flex-grow of 2.
 So the flex-grow is relative to size of the flex item.

Also there's a shorten prop which stands for flex-grow, flex-shrink and flex-basis, which that shorten prop is called flex.
So saying flex-grow: 1; is the same as saying: flex: 1;
So a simple trick to expand a flex-item to occupy as much width as it can, is simply setting it's flex prop to 1.

Learn: By using flex-basis, we can set the width of a flex item. So instead of using the width prop on a flex item, we usually use
 flex-basis. EX) flex-basis: 20%; on a flex-item means it's width is 20% of width of the flex-container then the other flex-items
 (if they don't have flex-basis or width property set for them, or if they have, the value of those props set to auto) have their
 flex-basis set to auto, which is the initial value for flex-basis and by having flex-basis: auto; or width: auto; on flex-items,
 they occupy the space that they need and if a flex-item has a flex: 1; the remaining space is occupied by that item.

flex-shrink: When the width of viewport decreases, if an item has flex-basis: 1; , it becomes smaller and smaller. That's because
it has less and less space that it occupies, so it becomes smaller. Now if you further decrease the width of viewport, if a flex
item has a flex-basis set to for example 300px which is a static width, you see that element also gets smaller.
So even if we set the flex-basis of an item to 300px, in other words, we set the width to 300px, it still starts decreasing, when
there's no more available space for that item, so it also gets smaller like when we set an item to flex: 1; . But the difference is
in case of flex-basis: 300px; the width of that item is static but when instead it has flex: 1; it's width is dynamic and gets all of
the available space.

When the width of viewport gets too small, there's 2 scenarios. 1 is gets smaller and the 2 is it gets completely cut off.
We can change that getting smaller(and make it getting COMPLETELY cut when it can't afford it's width of content and therefore that
item completely cut off, when there's no space) behavior, by using flex-shrink, because
flex-shrink controls how an element can shrink and flex-shrink has the initial value of 1 and 1 means the item is allowed
to shrink and that's why in those 2 prior cases we see the element starts getting smaller and smaller when when there's
no available space(for static width prop) and also gets smaller from the beginning of decreasing the viewport width in the
dynamic case(when the item has flex: 1;).
Now if we don't want that getting smaller to happen, we set it's flex-shrink to 0. Now those items get clipped, right? NOOO!
Actually viewport increases it's width by getting a scrollbar in order to fit those show us ALL of the items, even the items
that are currently cut of and we can see them only by scrolling(so basically we would have overflowing of those items out of their
flex container).
So by using flex-shrink, that item doesn't change it's width because it's not allowed to shrink.

The good practice is to use flex shorthand prop instead of flex-basis, flex-shrink or ... and USUALLY we want elements to actually
be able to shrink. Because we don't want that situation where the elements no longer fit the container(why don't fit the container?
Because their width don't change by changing the width of viewport). */
/* 5. A basic intro to flexbox - Adding more flex items:
Now if you add a whole lot of items into existing items, they are now getting CRAMPED into ONE LINE and if we decrease the width
of viewport, then there's even less and less space available for items and at last at some point, they even start overflowing from
the flex container. But there's another prop that we can use on flex container and it's flex-wrap and it's initial value is nowrap
and that's because the container is not wrapping into a new line, but if we say: flex-wrap: wrap; , then it will create a new line
for the flex items that no longer fit their container into one line. Now if you decrease the viewport, you see more and more items
come down to the next lines which is created as the flex items start to wrap. This can be pretty useful for responsive design, when
we get less and less space to work with it, in our layouts.

If you set an explicit high height for the container and if you got more than one row for items to wrap the container, you see that
there's quite a vertical space between LINES(rows of container). Why?
That's because of align-content prop that we can set on container. Now if you set align-content to flex-start, you see all of
the rows(why rows? Because we must have multiple rows to see that effect of having lot of vertical space) move up and that's
because what align-content prop does, is it allows rows along the cross axis. So it's pretty similar to align-items with the
difference that align-items, align the flex ITEMS(not rows), but align-content, align rows(affect the entire layout of that
container) along the cross axis.
Now because of align-content: flex-start; , the rows are stick to the beginning of cross axis and therefore all of the vertical
space that we have because of setting a high explicit height is empty. Also by setting align-content: flex-end; all of the
rows go to end of cross axis and we would have vertical space on top of them because of setting a high height in this case.

By suing align-content: center; ,the rows are centered along cross axis inside their flex container and that vertical space is
distributed between top and bottom space of group of rows. So align-content: center; make rows centered along cross axis.

align-content: space-around; distributes the space between rows so the space on the top and bottom of each of the rows is equal.
So just like justify-content: space-around;

align-content: space-between; pushes one of the rows to top(stick to top(when flex-direction: row;) or better say, to the
BEGINNING of cross axis) of the container and the last(by default) row to the end of cross axis.

align-content: stretch; is the default(so if you don't set it explicitely, it's there, implicitely). But in this case(in
align-content prop), the stretch value doesn't really all of the items like it does in align-items. It just stretches the ROWS,
which is not really visible. So this is pretty similar to align-content: space-between;
So align-content controls how the rows are aligned along the cross axis, similar to align-items which is for individual items, but
align-content is for rows of a container.

In package,json, I copied the scripts from last project but because we don't have the icon-font in this project, so there's not
really anything to concatenate, so I deleted concat:css script.
Also the input file for compile:sass is style.comp.css not style.concat.css , so I changed that too. So the build process in this
project is a bit smaller than the one in the previous project.
Also in build:css , we don't have the second step which was concat:sass , so I removed it from build:sass script.

We could also delete concat package completely from this project but I didn't do that.

So the build process is: compile, prefix and then compress.

7. Defining project settings and custom properties:
- How and why to use CSS custom properties instead of sass variables

In this project, we're not gonna focus on architecture and therefore we just wanna create 3 very simple files, one for base
settings, one for the overall layout of the app and one for our smaller components.

For box-sizing, FIRST we set the box-sizing: border-box; in html selector and then we make EVERYTHING inherit this prop. So
everything means the universal selector and also the ::after and ::before pseudo elements on universal selector.

So all the elements, as well as all the ::before and ::after pseudo elements should then inherit the box-sizing.

In this project, instead of using sass variables, we're gonna use CSS custom properties, which are better known as CSS variables.
That means, we can actually right now use variables in css and don't have to rely on sass variables.

But what's wrong with sass variables?
First advantage of css variables is if you're just using sass for it's variables you wouldn't need it anymore.
Second advantage is that css variables can be manipulated in JS and we can also edith them in our dev tools. Also it's easier
to use css variables in the code function and also css variables cascade and they're inherited.
So css variables are very different than sass variables.

CSS custom properties have to be defined inside a scope or in other words, within a declaration block(declaration blocks those
opening and closing curly brackets, so: <selector> {} .). Now, we COULD put those variables in any normal selector, like
any selector that we want, but by doing that, those variables would ONLY be available in that element(s) that matche(s)
that selector(which we defined those variables inside that selector) and it's children and that's what we want.

Moreover, it's easier to ONLY have one CENTRAL place where we collect all of the variables in one place and that place is
usually :root pseudo class and that :root is essentially like the same thing as html selector but with a higher specifity.
By putting all of our variables there, they will be accessible throughout the entire document, because that's what the root
of the document is. It's like the global parent element and therefore all the variables we declare there, will be available to
all the child elements.

So custom properties are very similar to a normal css prop. EX) We have margin: 0; and in custom props, we have --<>: ...;
The only difference is we use -- in order to distinguish between our custom props and a normal built-in css prop.

So now let's define :root{} on top of * selector.

For defining a gradient, we use the background-image prop and then probably, we use the background-size prop. */
/* 8. Building the overall layout:
1) How to think about the overall layout of an app
2) Use flexbox for a real world project for the first time

First we have a huge container that holds the entire app interface and that container is nicely centered vertically and
horizontally in the viewport. So that's the first element of the layout. Then in that container, first we have a header part.
Then below that we have 2 big parts. The first one is the sidebar which has navigation in itself and a small legal text and
in it's right, we have the hotel overview which is a huge block that contain those information about the hotel that we're
currently watching.
So those were 3 big parts inside the container. So the header on top, then the sidebar on the left and on right side we have
a huge block which is for hotel view. So let's write them in html.

In order to position those 2 sidebar and the hotel view which must sit next to each other, we actually need a container for
them and let's call it content as it's class. So let's create <div class="content"></div> for their container.
(I think we could make those 2 sidebar and hotel view sit next to each other without a container in normal css, but in
flexbox, we need a flex container for them, because they're flex items for a common flex container.)
So that <div class="content"> is the entire part below the header.
Learn: For sidebar, we can use the <nav> element, because a sidebar mainly holds a navigation. So <nav> is the best elemnt
 to convey that meaning to the element.
Also for hotel-view we use the <main> element because it's the perfect element for that, because the <main> element is where
the main part of website or web app goes and in this case, that main part of our page is hotel view, so we use <main> element
for hotel view and that's our overall layout. So we have the container, then in it, the header and below it the content which
in that content in it's left, we have the sidebar which has a navigation and on right side of content area, we have the
hotel-view. Now let's go to layout.scss and style those classes.

9. Building the header - Part 1:
1) Why to use svg icons vs font icons(so why it's better to use svg images as icons instead of an icon font)
2) How to find, generate and use svg sprites in HTML
3) How to change the color of an svg icon in css
4) How to use more advanced flexbox alignment techniques, including justify-content, align-items, align-self and flex

In our header we basically have 3 main components, we have the logo, then we have the search bar with the input field and the
search icon and then on the right, we have sth that we can call it user navigation. In that user navigation, we have like
bookmarks, a chat functionality and the name of the user. So the 3 main components in heade are logo, search bar and user
navigation.

For the search bar we used the form element and that search icon is a <button> element and inside that <button>, we have the
magnifying icon.
In natours project, we used icon FONTS, but this time we're gonna use SVGs AS ICONS. Why we're moving away from icon fonts
to svgs?
Well there are several problems with icon fonts. First one is that they're really just a HACK to display icons which are like
images using a font. Also icon fonts fail more often than you would think and if they fail, the browser just displays a
blank square or sth like that on the screen and that's terrible and there are actually other issues like screen readers for
blind people trying to read the icon fonts and of course, failing to do so and because of all that, right now it's considered
a best practice to move away from icon fonts and use SVGs. Now what's svg actually?
SVG stands for scalable vector graphics and it's a way of writing vector graphics with code. But we don't write any svg code
here, instead, we can use an app called icoMoon.io. In that site, you can upload an icon font if you want and it will convert it
to SVG. But you can also select some icons from their free library. In this project we used Entypo+. After selecting your icons,
select svg & more then click prefences, there, you can uncheck PNG because we didn't need PNGs, we just needed svg icons and
you can see in left bottom and on top of download button, you see it's svg. So hit download button. In the downloaded folder,
we just need the svg files which are in SVG folder and more importantly, we need symbol-defs.svg and that file is called
sprite file. So what's a sprite file?
It's an SVG file which contains all of those selected svg images from icomoons, in it. So that's the one that we're gonna
actually use. Because this way, we only have to use ONE GLOBAL file, which is the symbol-defs.svg file and from there, we can
select each of the icons and so this way, we only have ONE http request for ONE file instead of having to include all of those
10 different icon files.
Learn: So icon sprites, like the symbol-defs.svg file, is the way to go and professional do that.
Also we have a html file when download from icomoons called demo.html which by opening it, we can see the names
of the icons that we can use them in html file of our website.

Now for using the downloaded icons, grab SVG folder and sprite file and move them to img folder and you can rename the
symbol-defs.svg file to sprite.svg .(Also I deleted the sprite file that I originally cloned from the course repo and just
renamed OUR symbol-defs.svg file to sprite.svg .) Also I left that SVG folder with those initial svg files in it, there,
because maybe we'll need one of them later. Now we're ready to use the sprite.svg file.

Now how we include an svg icon? We use <svg> element and I used it inside the <button> element. Then inside <svg> we have
to use the <use> and on that, an attr called xlink:href .
So that's how we can include an svg file and then reference each separate icon in there. So we reference the sprite file for
xlink:href attr and also the svg icon that you want to use there and you can see the name of the icon in demo.html file.
For specifying the name of svg icon in the sprite file, we use # sign after the name of the sprite file and it's extension which
is svg. So:
<use xlink:href="<path to sprite file and then name of that file>#<name of svg icon without the svg extension>"></use>

Remember: In the beginning of name of svg icon, we have the prefix class which we can change it in prefences when we are
downloading those selected icons.

So that was the best way to include svg files in HTML, by using svg sprite files. Why it's best way?
Because that way, we can actually change the color of each of the icons using css.

Using(including them in html files) svg files with the xlink:href attr, is only gonna work on a web server. So ONLY on a
web server you'll be able to see that sprite svg file, but since we ARE actually using a web server(currently in development
we're using a LOCAL web server- the localhost server), that's why we can see those icons. But those svg icons currently are
not styled at all.
Another advantage of svg, is that it makes it really easy to style those svg icons. But with font based icons, it's always
really hard to put them exactly the way we want it.

For user navigation I used the <nav> html5 element and in that <anv> element, we'll put 3 boxes, which those boxes are <div>
elements.
Also we want a notification indicator on top left corner of some of svgs, for that I used an <span> element next to where we
defined <svg> elements for icons.

After writing html, the images and svg icons are very huge so let's style them quickly. So let's go to components.scss file.
In this project, we put all of the styles of each component in just 1 file which is components.scss .
So let's quickly give some height prop for our images and(it's not good to give height AND width to an image-so we specified only the
height prop for that image) ... .

How we style an svg icon?(for sizing styles)
It's really easy, compared to font icons. All we have to do is to set the <svg>'s height and width in order to size it the way we
want.
Important: For the logo which is an <img> element we didn't use BOTH width and height, but for the svgs, we did.

We can make an <img> circle, by giving it a border-radius: 50%;*/
/* 10. Building the header - Part 2:
First let's put those 3 elements that we have inside <header>, side by side. How do we do that?
We use flexbox. Now what should be the flex container in that case(the header)?
Well, it should be the parent element of the elements that we want them to be side by side. Those elements that we want them be
side by side are the logo, the search bar and the user navigation and the parent of those elements is the <header> element. So
let's set the display of .header to flex and that will put the children of that element, side by side.

Now we want the .user-nav to go all the way to the right side and then the search bar in the middle. So we need to use justify-content
which align the ITEMS along the MAIN axis. We need space-between for it's value and it will divide the empty space between those 3
elements. So we used space-between because with this value, it won't put space on outer spaces and we just want a LITTLE space in
outer elements(the left of first item and right of last item) with a little margin and not from the result of space-around, which
would put a lot of space in outer spaces.
Now we also want to align those 3 elements along the cross axis and with that alignment, for example we would have the
logo nicely centered in the header along the cross axis which currently is from top to bottom. If we didn't use flexbox, we could
use margin-top and then we have to EXPERIMENT which value is the perfect margin?
Important: So one of the things that we can do for vertical alignment of some elements is to give them a margin-top and play with
 it's value(Possibly we can give another <div> for grouping those elements inside their container and give a margin-top to that
 <div> instead of giving that margin-top to each of those items. So that <div> would be the direct child of the original <div> which
 we wanted to align vertically the items of that original <div> inside it, therefore we grouped those items with another <div>).
 But with flexbox, we can use align-items in this case.
After doing that, we see that the .user-nav is overflowing from the flex container which is the <header> and that's because
there's too much content inside that .user-nav and therefore the height of that item is more than the SPECIFIED height of the
container and therefore it overflows but it's vertically centered anyways.
In before the align-items was set to stretch(the default value) so you saw that the search bar was occupying the entire space from
top to bottom. Now let's style each of those items.

For giving a width or ... to a flex item, we should use the flex shorthand prop, instead of using width prop or ... .

11. Building the header - Part 3:
The first thing we need to do about the 3 elements in .user-nav, is to make them side by side. So we need to make their parent
which is .user-nav, a flex container. */
/* 12. Building the navigation - Part 1:
1) How to use scaleY() and multiple transition properties with different settings, to create a creative hover effect
2) How and why to use currentColor css variable
3) How to use more advanced flexbox alignment techniques, including flex-direction, justify-content and align-items

The best way of including svg in html is the way we did it. Which is by only including ONE FILE(which is the sprite.svg file instead
of including multiple svg files of svg icons-so we have ONE file that has all of our svg icons). So for our icons, we included only
one file multiple times. So that is the SAME FILE, therefore we only would have ONE HTTP request for all of those svgs. So that's the
whole goal of having a sprite image.

Remember: After writing the html markup for <svg> elements and before style and sizing them, you may see that they're huge on the page.
But you can size them in css.

Also after writing the html for sidebar, you see that the hotel-view is stretched all the way until the bottom of it's container.
Because we're using flexbox and since the default value of align-items is stretch, well, they will both stretch all the way they can along
the cross axis. So when you increase the height of one of the items, AUTOMATICALLY(because the align-items is set to stretch) the height
of other items increase as much as that too. So all of the items have the same height and actually the height of the container is equal
to height of the highest item(because we didn't set any height for container). Usually that's the behavior that we want.(All of the items
have the same height.)

By setting flex-direction other value than the default, you change the direction of MAIN axis.

13. Building the navigation - Part 2:
Learn: The first parent of a pseudo element like ::before is actually the element that we set that pseudo element on it.
 So if you set a pseudo element on <li> , that <li> is the direct parent of that pseudo element.

14. Building the Hotel Overview - Part 1:
1) How to create an infinite animation
2) How to use margin: auto; with flexbox and why it's so powerful
3) Continue to use flexbox properties for easy positioning and alignment

In .gallery we wrap each of the images in a <figure> element, so we can later add a <figcaption> element there, in order to give those
images a caption.

15. Building the Hotel Overview - Part 2:


16. Building the Description Section - Part 1:
1) Continue to use flexbox, including flex-wrap to build a multi-column list
2) How and why to use css masks with mask-image and mask-size

17. Building the Description Section - Part 2:
Important: As I mentioned, we usually just give a height or just a width to an <img>, but when we want to make it circle, we give
 it both height and width with equal values and border-radius of 50%. Like what we did in .recommend__photo .

18. Building the User Reviews Section - Part 1:
*/
@import "base";
@import "layout";
@import "components";





